use crate::analyzer::{
    AnnotatedExpr, AnnotatedExprList, AnnotatedFunction, AnnotatedProgram, AnnotatedStmt,
    AnnotatedTopLevelItem, AnnotatedVariableDecl,
};
use crate::parser::ast::*;
use emitter::Emitter;
use mangler::Mangler;
use miette::Error;
use std::borrow::Cow;

mod emitter;
mod mangler;

#[derive(Debug)]
pub struct Codegen<'de> {
    program: AnnotatedProgram<'de>,
    emitter: Emitter,
    mangler: Mangler,
    label_counter: u64,
}

impl<'de> Codegen<'de> {
    /// Create a Codegen from an annotated program
    pub fn from_annotated_program(
        name: String,
        program: AnnotatedProgram<'de>,
    ) -> Result<Self, Error> {
        Ok(Self {
            program,
            emitter: Emitter::default(),
            mangler: Mangler::new(name),
            label_counter: 0,
        })
    }

    /// Create a Codegen from an annotated program (alias for convenience)
    #[allow(dead_code)]
    pub fn from_program(name: String, program: AnnotatedProgram<'de>) -> Result<Self, Error> {
        Self::from_annotated_program(name, program)
    }

    /// Generate a unique label
    fn generate_label(&mut self, prefix: &str) -> String {
        let label = format!("{}_{}", prefix, self.label_counter);
        self.label_counter += 1;
        label
    }

    fn codegen(&mut self) {
        // Emit a small header comment
        self.emitter.write_comment("generated by novac");

        // Declare external symbols for builtins
        self.emitter.write_txt("extern printf");
        self.emitter.write_txt("extern abort");
        self.emitter.write_txt("extern fflush");

        // Track main function's mangled name for _start entry point
        let mut main_function_name: Option<String> = None;

        // First pass: find main function name
        for item in &self.program.items {
            if let AnnotatedTopLevelItem::Function(func) = item {
                if func.name.as_ref() == "main" {
                    let param_types: Vec<Type> = func
                        .params
                        .iter()
                        .map(|p| p.type_annotation.clone())
                        .collect();
                    let generics: Option<Vec<&str>> = if func.generics.is_empty() {
                        None
                    } else {
                        Some(func.generics.iter().map(|g| g.as_ref()).collect())
                    };
                    let label = self.mangler.mangle_function(
                        func.name.as_ref(),
                        &param_types,
                        &func.return_type,
                        generics.as_deref(),
                    );
                    main_function_name = Some(label);
                    break;
                }
            }
        }

        // Always emit _start entry point
        // If main exists, call it; otherwise just exit
        if let Some(ref main_name) = main_function_name {
            self.emit_start_entry_point(main_name);
        } else {
            self.emit_start_entry_point_no_main();
        }

        // Clone items to avoid borrowing `self` immutably while we mutate `self`
        let items = self.program.items.clone();
        for item in items {
            match item {
                AnnotatedTopLevelItem::Function(func) => {
                    // Mangle function with type information from annotated AST
                    let param_types: Vec<Type> = func
                        .params
                        .iter()
                        .map(|p| p.type_annotation.clone())
                        .collect();
                    let generics: Option<Vec<&str>> = if func.generics.is_empty() {
                        None
                    } else {
                        Some(func.generics.iter().map(|g| g.as_ref()).collect())
                    };
                    let label = self.mangler.mangle_function(
                        func.name.as_ref(),
                        &param_types,
                        &func.return_type,
                        generics.as_deref(),
                    );

                    // Main function already handled in first pass

                    // x86_64 / System V: export symbol (NASM syntax)
                    self.emitter.write_txt(&format!("global {}", label));
                    self.emitter.write_txt_label(&label);
                    self.emitter
                        .write_comment(&format!("function {}", func.name));
                    // System V prologue
                    self.emitter.write_txt("push rbp");
                    self.emitter.write_txt("mov rbp, rsp");

                    // Count local variables to allocate stack space
                    let local_count = Self::count_local_variables(&func.body);
                    // Always allocate at least 16 bytes for temporary storage (e.g., format strings in printf)
                    let stack_size = if local_count > 0 {
                        // Allocate space for locals (8 bytes each, aligned to 16 bytes)
                        ((local_count * 8 + 15) / 16) * 16
                    } else {
                        // No locals, but allocate 16 bytes for temporary storage
                        16
                    };
                    self.emitter.write_txt(&format!("sub rsp, {}", stack_size));

                    // Parameter register mapping
                    let mut param_regs: Vec<(&str, &str)> = Vec::new();
                    for (i, p) in func.params.iter().enumerate() {
                        param_regs.push((p.name.as_ref(), Self::reg_for_param(i)));
                    }

                    // Create local variable map (stack offsets)
                    let mut locals: std::collections::HashMap<&str, i32> =
                        std::collections::HashMap::new();
                    let mut stack_offset = 8; // Start at rbp - 8
                    for stmt in Self::get_statements(&func.body) {
                        if let AnnotatedStmt::VariableDecl(var) = stmt {
                            locals.insert(var.name.as_ref(), stack_offset);
                            stack_offset += 8; // Each local is 8 bytes (64-bit)
                        }
                    }

                    // Lower the function body into instructions
                    self.generate_function_body_with_locals(&func, &param_regs, &locals);

                    // System V epilogue
                    self.emitter.write_txt("leave");
                    self.emitter.write_txt("ret");
                }
                AnnotatedTopLevelItem::VariableDecl(var) => {
                    // Use type from annotated AST
                    let label = self
                        .mangler
                        .mangle_variable(var.name.as_ref(), &var.type_annotation);
                    match var.value.expr {
                        Expr::Literal(Literal::String(ref s)) => {
                            // data symbol, align and export (NASM syntax)
                            self.emitter.write_dat(&format!("global {}", label));
                            self.emitter.write_dat(&format!("align 8"));
                            self.emitter.emit_data_string(&label, s.as_ref());
                        }
                        Expr::Literal(Literal::Number(n)) => {
                            self.emitter.write_dat(&format!("global {}", label));
                            self.emitter.write_dat(&format!("align 8"));
                            self.emitter.write_dat_label(&label);
                            self.emitter.write_dat(&format!("dq {}", n));
                        }
                        _ => {
                            // fallback: emit label and a comment placeholder
                            self.emitter.write_dat_label(&label);
                            self.emitter.write_dat("; unhandled initializer");
                        }
                    }
                }
                AnnotatedTopLevelItem::TypeDecl(_) => {
                    // TODO: emit type declarations when needed
                }
            }
        }
    }

    /// Emit _start entry point that calls main and exits
    fn emit_start_entry_point(&mut self, main_function_name: &str) {
        // Export _start as global (this is the entry point)
        self.emitter.write_txt("global _start");
        self.emitter.write_txt_label("_start");
        self.emitter.write_comment("entry point");

        // Call main function (no arguments, main() -> nil)
        // Main function expects no arguments, so we don't need to set up registers
        self.emitter
            .write_txt(&format!("call {}", main_function_name));

        // Exit with the return value from main (or 0 if main returns nil)
        // Linux x86_64 syscall: exit(exit_code)
        // syscall number 60 = SYS_exit
        // rdi = exit code (already in rax from main)
        self.emitter.write_txt("mov rdi, rax"); // Move return value to rdi (exit code)
        self.emitter.write_txt("mov rax, 60"); // syscall number for exit
        self.emitter.write_txt("syscall"); // invoke syscall
    }

    /// Emit _start entry point when there's no main function (just exit)
    fn emit_start_entry_point_no_main(&mut self) {
        // Export _start as global (this is the entry point)
        self.emitter.write_txt("global _start");
        self.emitter.write_txt_label("_start");
        self.emitter.write_comment("entry point (no main function)");

        // Exit immediately with code 0
        // Linux x86_64 syscall: exit(exit_code)
        // syscall number 60 = SYS_exit
        self.emitter.write_txt("mov rdi, 0"); // Exit code 0
        self.emitter.write_txt("mov rax, 60"); // syscall number for exit
        self.emitter.write_txt("syscall"); // invoke syscall
    }

    fn reg_for_param(i: usize) -> &'static str {
        match i {
            0 => "rdi",
            1 => "rsi",
            2 => "rdx",
            3 => "rcx",
            4 => "r8",
            5 => "r9",
            _ => "rdi",
        }
    }

    fn generate_function_body_with_locals(
        &mut self,
        func: &AnnotatedFunction<'de>,
        params: &Vec<(&str, &str)>,
        locals: &std::collections::HashMap<&str, i32>,
    ) {
        // Only handle simple bodies for now: Single(expr) or Block with return
        match &func.body {
            AnnotatedExprList::Single(expr) => {
                self.emit_expr_to_rax_with_locals(expr, params, locals);
            }
            AnnotatedExprList::Block(stmts) => {
                self.emit_block_to_rax_with_locals(stmts, params, locals);
            }
        }
    }

    /// Emit a block of statements, returning the result in rax
    fn emit_block_to_rax_with_locals(
        &mut self,
        stmts: &[AnnotatedStmt<'de>],
        params: &Vec<(&str, &str)>,
        locals: &std::collections::HashMap<&str, i32>,
    ) {
        for stmt in stmts {
            match stmt {
                AnnotatedStmt::Return(Some(expr)) => {
                    self.emit_expr_to_rax_with_locals(expr, params, locals);
                    return;
                }
                AnnotatedStmt::Expr(expr) => {
                    let _ = self.emit_expr_to_rax_with_locals(expr, params, locals);
                }
                AnnotatedStmt::VariableDecl(var) => {
                    // Evaluate initializer
                    self.emit_expr_to_rax_with_locals(&var.value, params, locals);
                    // Store to stack location
                    if let Some(&offset) = locals.get(var.name.as_ref()) {
                        self.emitter
                            .write_txt(&format!("mov [rbp - {}], rax", offset));
                    }
                }
                AnnotatedStmt::Return(None) => {
                    self.emitter.write_txt("mov rax, 0");
                    return;
                }
            }
        }
        // If no return statement, result is nil/0
        self.emitter.write_txt("mov rax, 0");
    }

    /// Count local variables in a function body
    fn count_local_variables(body: &AnnotatedExprList<'de>) -> usize {
        match body {
            AnnotatedExprList::Single(_) => 0,
            AnnotatedExprList::Block(stmts) => stmts
                .iter()
                .filter(|s| matches!(s, AnnotatedStmt::VariableDecl(_)))
                .count(),
        }
    }

    /// Get all statements from a function body
    fn get_statements<'a>(body: &'a AnnotatedExprList<'de>) -> Vec<&'a AnnotatedStmt<'de>> {
        match body {
            AnnotatedExprList::Single(_) => vec![],
            AnnotatedExprList::Block(stmts) => stmts.iter().collect(),
        }
    }

    /// Emit a block of statements (legacy version without locals)
    #[allow(dead_code)]
    fn emit_block_to_rax(&mut self, stmts: &[AnnotatedStmt<'de>], params: &Vec<(&str, &str)>) {
        let empty_locals = std::collections::HashMap::new();
        self.emit_block_to_rax_with_locals(stmts, params, &empty_locals);
    }

    #[allow(dead_code)]
    fn emit_expr_to_rax(&mut self, expr: &AnnotatedExpr<'de>, params: &Vec<(&str, &str)>) {
        let empty_locals = std::collections::HashMap::new();
        self.emit_expr_to_rax_with_locals(expr, params, &empty_locals);
    }

    fn emit_expr_to_rax_with_locals(
        &mut self,
        annotated_expr: &AnnotatedExpr<'de>,
        params: &Vec<(&str, &str)>,
        locals: &std::collections::HashMap<&str, i32>,
    ) {
        // Pattern match on the underlying expression
        match &annotated_expr.expr {
            Expr::Literal(Literal::Number(n)) => {
                self.emitter.write_txt(&format!("mov rax, {}", n));
            }
            Expr::Literal(Literal::Boolean(b)) => {
                if *b {
                    self.emitter.write_txt("mov rax, 1");
                } else {
                    self.emitter.write_txt("mov rax, 0");
                }
            }
            Expr::Literal(Literal::Char(c)) => {
                self.emitter.write_txt(&format!("mov rax, {}", *c as u64));
            }
            Expr::Literal(Literal::Nil) => {
                self.emitter.write_txt("mov rax, 0");
            }
            Expr::Literal(Literal::String(s)) => {
                // String literal - should be handled specially in builtin calls
                // For now, emit a comment and set rax to 0
                // In practice, string literals should be in .data section
                self.emitter
                    .write_comment(&format!("string literal: {}", s));
                // Generate a label for the string
                let label = self.generate_label("str_lit");
                self.emitter.emit_data_string(&label, s);
                self.emitter.write_txt(&format!("mov rax, {}", label));
            }
            Expr::Literal(Literal::BuiltinCall(builtin)) => {
                self.emit_builtin_call(builtin, annotated_expr, params, locals);
            }
            Expr::Ident(name) => {
                // Check if it's a local variable
                if let Some(&offset) = locals.get(name.as_ref()) {
                    self.emitter
                        .write_txt(&format!("mov rax, [rbp - {}]", offset));
                } else if let Some((_, reg)) = params.iter().find(|(n, _)| n == &name.as_ref()) {
                    // It's a parameter
                    self.emitter.write_txt(&format!("mov rax, {}", reg));
                } else {
                    // It's a global variable - use type information for better mangling
                    let g = self
                        .mangler
                        .mangle_variable(name.as_ref(), &annotated_expr.ty);
                    // NASM syntax: use [rel symbol] for position-independent code
                    self.emitter.write_txt(&format!("mov rax, [rel {}]", g));
                }
            }
            Expr::Binary { left, op, right } => {
                // left and right are Box<Expr>, need to create AnnotatedExpr wrappers
                // Infer types for nested expressions
                let left_ty = Self::infer_type_from_expr_simple(left)
                    .unwrap_or_else(|| annotated_expr.ty.clone());
                let right_ty = Self::infer_type_from_expr_simple(right)
                    .unwrap_or_else(|| annotated_expr.ty.clone());

                let left_annotated = AnnotatedExpr::new(*left.clone(), left_ty);
                let right_annotated = AnnotatedExpr::new(*right.clone(), right_ty);

                // Evaluate left into rax
                self.emit_expr_to_rax_with_locals(&left_annotated, params, locals);

                // Prepare right operand
                let right_op = match &right_annotated.expr {
                    Expr::Literal(Literal::Number(n)) => format!("{}", n),
                    Expr::Ident(n) => {
                        // Check if it's a local variable
                        if let Some(&offset) = locals.get(n.as_ref()) {
                            format!("[rbp - {}]", offset)
                        } else if let Some((_, reg)) =
                            params.iter().find(|(name, _)| name == &n.as_ref())
                        {
                            (*reg).to_string()
                        } else {
                            // Use type information for better mangling
                            let g = self
                                .mangler
                                .mangle_variable(n.as_ref(), &right_annotated.ty);
                            format!("[rel {}]", g)
                        }
                    }
                    _ => {
                        self.emit_expr_to_rcx_with_locals(&right_annotated, params, locals);
                        "rcx".to_string()
                    }
                };

                match op {
                    BinOp::Add => self.emitter.write_txt(&format!("add rax, {}", right_op)),
                    BinOp::Sub => self.emitter.write_txt(&format!("sub rax, {}", right_op)),
                    BinOp::Mul => self.emitter.write_txt(&format!("imul rax, {}", right_op)),
                    BinOp::Div => {
                        // Signed division: sign-extend rax into rdx:rax, then divide
                        self.emitter.write_txt("cqo");
                        if right_op.chars().all(|c| c.is_ascii_digit()) {
                            self.emitter.write_txt(&format!("mov rcx, {}", right_op));
                            self.emitter.write_txt("idiv rcx");
                        } else {
                            self.emitter.write_txt(&format!("idiv {}", right_op));
                        }
                    }
                    BinOp::Rem => {
                        // Modulo: same as division, but remainder is in rdx
                        self.emitter.write_txt("cqo");
                        if right_op.chars().all(|c| c.is_ascii_digit()) {
                            self.emitter.write_txt(&format!("mov rcx, {}", right_op));
                            self.emitter.write_txt("idiv rcx");
                        } else {
                            self.emitter.write_txt(&format!("idiv {}", right_op));
                        }
                        // Move remainder from rdx to rax
                        self.emitter.write_txt("mov rax, rdx");
                    }
                    BinOp::Pow => {
                        // Exponentiation: for now, use a simple iterative approach
                        // TODO: optimize for constant powers
                        self.emitter
                            .write_comment("exponentiation not fully implemented");
                        // Placeholder: just multiply (only works for power of 1)
                        self.emitter.write_txt("mov rax, 1");
                    }
                    // Comparison operations
                    BinOp::Eq => {
                        self.emitter.write_txt(&format!("cmp rax, {}", right_op));
                        self.emitter.write_txt("sete al");
                        self.emitter.write_txt("movzx rax, al");
                    }
                    BinOp::Ne => {
                        self.emitter.write_txt(&format!("cmp rax, {}", right_op));
                        self.emitter.write_txt("setne al");
                        self.emitter.write_txt("movzx rax, al");
                    }
                    BinOp::Lt => {
                        self.emitter.write_txt(&format!("cmp rax, {}", right_op));
                        self.emitter.write_txt("setl al");
                        self.emitter.write_txt("movzx rax, al");
                    }
                    BinOp::Gt => {
                        self.emitter.write_txt(&format!("cmp rax, {}", right_op));
                        self.emitter.write_txt("setg al");
                        self.emitter.write_txt("movzx rax, al");
                    }
                    BinOp::Le => {
                        self.emitter.write_txt(&format!("cmp rax, {}", right_op));
                        self.emitter.write_txt("setle al");
                        self.emitter.write_txt("movzx rax, al");
                    }
                    BinOp::Ge => {
                        self.emitter.write_txt(&format!("cmp rax, {}", right_op));
                        self.emitter.write_txt("setge al");
                        self.emitter.write_txt("movzx rax, al");
                    }
                    // Logical operations
                    BinOp::And => {
                        // Logical AND: both operands must be non-zero
                        // Test left operand (already in rax)
                        self.emitter.write_txt("test rax, rax");
                        // If left is zero, result is zero, else check right
                        let end_label = self.generate_label("and_end");
                        let check_right_label = self.generate_label("and_check_right");
                        self.emitter.write_txt(&format!("jz {}", end_label));
                        self.emitter
                            .write_txt(&format!("jmp {}", check_right_label));
                        self.emitter.write_txt_label(&check_right_label);
                        // Evaluate right operand to rcx (right_annotated already created above)
                        self.emit_expr_to_rcx_with_locals(&right_annotated, params, locals);
                        self.emitter.write_txt("test rcx, rcx");
                        self.emitter.write_txt("mov rax, 0");
                        self.emitter.write_txt(&format!("jz {}", end_label));
                        self.emitter.write_txt("mov rax, 1");
                        self.emitter.write_txt_label(&end_label);
                    }
                    BinOp::Or => {
                        // Logical OR: at least one operand is non-zero
                        // Test left operand (already in rax)
                        self.emitter.write_txt("test rax, rax");
                        let end_label = self.generate_label("or_end");
                        let check_right_label = self.generate_label("or_check_right");
                        self.emitter.write_txt(&format!("jnz {}", end_label));
                        self.emitter
                            .write_txt(&format!("jmp {}", check_right_label));
                        self.emitter.write_txt_label(&check_right_label);
                        // Evaluate right operand to rcx (right_annotated already created above)
                        self.emit_expr_to_rcx_with_locals(&right_annotated, params, locals);
                        self.emitter.write_txt("test rcx, rcx");
                        self.emitter.write_txt("mov rax, 0");
                        self.emitter.write_txt(&format!("jz {}", end_label));
                        self.emitter.write_txt("mov rax, 1");
                        self.emitter.write_txt_label(&end_label);
                    }
                    BinOp::Concat => {
                        // String concatenation: defer for now
                        self.emitter
                            .write_comment("string concatenation not implemented");
                        self.emitter.write_txt("mov rax, 0");
                    }
                }
            }
            Expr::Unary { op, expr } => {
                // Evaluate operand first
                // The expr here is Box<Expr>, but we need AnnotatedExpr
                // Since we're in an AnnotatedExpr context, we can infer the operand type
                // For negation, operand type is same as result type
                // For logical not, operand should be bool, result is bool
                let operand_ty = match op {
                    UnaryOp::Neg => annotated_expr.ty.clone(), // Same type as result
                    UnaryOp::Not => Type::Primitive(PrimitiveType::Bool),
                };
                let operand_annotated = AnnotatedExpr::new(*expr.clone(), operand_ty);
                self.emit_expr_to_rax_with_locals(&operand_annotated, params, locals);
                match op {
                    UnaryOp::Neg => {
                        // Negation: negate the value
                        self.emitter.write_txt("neg rax");
                    }
                    UnaryOp::Not => {
                        // Logical NOT: 0 -> 1, non-zero -> 0
                        self.emitter.write_txt("test rax, rax");
                        self.emitter.write_txt("sete al");
                        self.emitter.write_txt("movzx rax, al");
                    }
                }
            }
            Expr::Call { callee, args } => {
                // Check if this is a method call disguised as a function call
                // (e.g., my_person.intro() is parsed as Call with Member callee)
                if let Expr::Member {
                    object,
                    field: MemberField::Name(method_name),
                } = callee.as_ref()
                {
                    // Extract method name to avoid borrow issues
                    let method_name_str = method_name.as_ref().to_string();
                    // This is actually a method call: object.method_name(args)
                    // Treat it as an instance method call
                    let receiver_annotated = AnnotatedExpr::new(
                        *object.clone(),
                        Type::Primitive(PrimitiveType::I32), // Placeholder - will be improved
                    );
                    self.emit_expr_to_rax_with_locals(&receiver_annotated, params, locals);

                    // Save 'self' to rdi (first parameter)
                    self.emitter.write_txt("mov rdi, rax");

                    // Try to infer the receiver type from the annotated expression type
                    // For method calls, the annotated type might be the return type
                    // We need to look up the variable type instead
                    let _type_name: Option<&str> = if let Expr::Ident(_var_name) = object.as_ref() {
                        // Look up variable in locals or params to get its type
                        // For now, we'll try to infer from context
                        // This is a limitation - we should store variable types
                        None // Will be improved
                    } else {
                        None
                    };

                    // For now, try to find the method by looking through all types
                    // This is inefficient but works for now
                    // First, collect the method info without mutating self
                    let mut method_type_name: Option<String> = None;
                    let mut method_func: Option<Function<'de>> = None;
                    for item in &self.program.items {
                        if let AnnotatedTopLevelItem::TypeDecl(type_decl) = item {
                            if let TypeDeclKind::Struct(struct_decl) = &type_decl.decl {
                                if let Some(impl_block) = &struct_decl.impl_block {
                                    for func in impl_block {
                                        if func.name.as_ref() == method_name_str.as_str() {
                                            method_type_name =
                                                Some(type_decl.name.as_ref().to_string());
                                            method_func = Some(func.clone());
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        if method_func.is_some() {
                            break;
                        }
                    }

                    if let (Some(type_name), Some(func)) = (method_type_name, method_func) {
                        // Found a method! Evaluate arguments
                        let param_regs = ["rdi", "rsi", "rdx", "rcx", "r8", "r9"];

                        // Check if first param is 'self' - if so, skip it in arg evaluation
                        let args_to_pass = if func
                            .params
                            .first()
                            .map(|p| p.name.as_ref() == "self")
                            .unwrap_or(false)
                        {
                            args
                        } else {
                            args
                        };

                        // Evaluate remaining arguments (skip rdi which has 'self')
                        for (i, arg_expr) in args_to_pass.iter().take(5).enumerate() {
                            let arg_annotated = AnnotatedExpr::new(
                                arg_expr.clone(),
                                Type::Primitive(PrimitiveType::I32), // Placeholder
                            );
                            self.emit_expr_to_rax_with_locals(&arg_annotated, params, locals);
                            self.emitter.write_txt("mov r10, rax");
                            self.emitter
                                .write_txt(&format!("mov {}, r10", param_regs[i + 1]));
                        }

                        // Generate mangled function name: TypeName_methodName
                        let method_label = self
                            .mangler
                            .mangle(&format!("{}:{}", type_name, method_name_str));
                        self.emitter.write_txt(&format!("call {}", method_label));
                        // Return value is already in rax
                        return;
                    }
                }

                // Regular function call: System V ABI
                // Evaluate arguments and place in System V parameter registers
                let param_regs = ["rdi", "rsi", "rdx", "rcx", "r8", "r9"];
                for (i, arg_expr) in args.iter().take(6).enumerate() {
                    // Create AnnotatedExpr wrapper (type will be inferred from context)
                    // For now, use a placeholder type
                    let arg_annotated = AnnotatedExpr::new(
                        arg_expr.clone(),
                        Type::Primitive(PrimitiveType::I32), // Placeholder
                    );
                    if i == 0 {
                        self.emit_expr_to_rax_with_locals(&arg_annotated, params, locals);
                        self.emitter
                            .write_txt(&format!("mov {}, rax", param_regs[i]));
                    } else {
                        // Use r10 as temporary for other arguments
                        self.emit_expr_to_rax_with_locals(&arg_annotated, params, locals);
                        self.emitter.write_txt("mov r10, rax");
                        self.emitter
                            .write_txt(&format!("mov {}, r10", param_regs[i]));
                    }
                }

                // More than 6 arguments would need stack, but we'll handle that later
                if args.len() > 6 {
                    self.emitter
                        .write_comment("more than 6 arguments not yet supported");
                }

                // Call the function
                if let Expr::Ident(name) = callee.as_ref() {
                    // Look up the function to get its mangled name with types
                    let func_label = self
                        .find_function_mangled_name(name.as_ref(), args)
                        .unwrap_or_else(|| {
                            // Fallback to simple mangling if function not found
                            self.mangler.mangle(name.as_ref())
                        });
                    self.emitter.write_txt(&format!("call {}", func_label));
                } else {
                    // Indirect call - evaluate callee to rax, then call
                    let callee_annotated = AnnotatedExpr::new(
                        *callee.clone(),
                        Type::Function { params: vec![] }, // Placeholder
                    );
                    self.emit_expr_to_rax_with_locals(&callee_annotated, params, locals);
                    self.emitter.write_txt("call rax");
                }
                // Return value is already in rax
            }
            Expr::Paren(expr) => {
                // Parentheses: just evaluate inner expression
                // Create AnnotatedExpr wrapper
                let inner_annotated = AnnotatedExpr::new(
                    *expr.clone(),
                    annotated_expr.ty.clone(), // Same type as outer
                );
                self.emit_expr_to_rax_with_locals(&inner_annotated, params, locals);
            }
            Expr::If {
                condition,
                then_block,
                elif_blocks,
                else_block,
            } => {
                // If/elif/else expression
                // Note: These are Vec<Stmt>, not AnnotatedStmt
                // We need to convert them or handle differently
                // For now, we'll need to work with the unannotated structure
                // TODO: The annotated AST should have AnnotatedIf with AnnotatedStmt

                // Evaluate condition
                let cond_annotated =
                    AnnotatedExpr::new(*condition.clone(), Type::Primitive(PrimitiveType::Bool));
                self.emit_expr_to_rax_with_locals(&cond_annotated, params, locals);
                self.emitter.write_txt("test rax, rax");

                let end_label = self.generate_label("if_end");
                let mut next_label = self.generate_label("if_else");

                // Jump to else/end if condition is false
                self.emitter.write_txt(&format!("jz {}", next_label));

                // Then block - convert Stmt to AnnotatedStmt
                let then_annotated: Vec<AnnotatedStmt> = then_block
                    .iter()
                    .map(|s| Self::stmt_to_annotated(s))
                    .collect();
                self.emit_block_to_rax_with_locals(&then_annotated, params, locals);
                self.emitter.write_txt(&format!("jmp {}", end_label));

                // Elif blocks
                for elif_block in elif_blocks {
                    self.emitter.write_txt_label(&next_label);
                    next_label = self.generate_label("if_else");

                    // Evaluate elif condition
                    let elif_cond_annotated = AnnotatedExpr::new(
                        *elif_block.condition.clone(),
                        Type::Primitive(PrimitiveType::Bool),
                    );
                    self.emit_expr_to_rax_with_locals(&elif_cond_annotated, params, locals);
                    self.emitter.write_txt("test rax, rax");
                    self.emitter.write_txt(&format!("jz {}", next_label));

                    // Elif body
                    let elif_body_annotated: Vec<AnnotatedStmt> = elif_block
                        .body
                        .iter()
                        .map(|s| Self::stmt_to_annotated(s))
                        .collect();
                    self.emit_block_to_rax_with_locals(&elif_body_annotated, params, locals);
                    self.emitter.write_txt(&format!("jmp {}", end_label));
                }

                // Else block (if present)
                if let Some(else_body) = else_block {
                    self.emitter.write_txt_label(&next_label);
                    let else_body_annotated: Vec<AnnotatedStmt> = else_body
                        .iter()
                        .map(|s| Self::stmt_to_annotated(s))
                        .collect();
                    self.emit_block_to_rax_with_locals(&else_body_annotated, params, locals);
                } else {
                    // No else: result is nil/0 if all conditions false
                    self.emitter.write_txt_label(&next_label);
                    self.emitter.write_txt("mov rax, 0");
                }

                self.emitter.write_txt_label(&end_label);
            }
            Expr::MethodCall {
                receiver,
                method,
                args,
            } => {
                self.emit_method_call(annotated_expr, receiver, method, args, params, locals);
            }
            Expr::Member { object, field } => {
                self.emit_member_access(annotated_expr, object, field, params, locals);
            }
            Expr::StructLit { type_, fields } => {
                self.emit_struct_literal(annotated_expr, type_, fields, params, locals);
            }
            Expr::EnumVariant { name, value } => {
                self.emit_enum_variant(annotated_expr, name, value, params, locals);
            }
            _ => {
                self.emitter
                    .write_comment(&format!("unhandled expr: {:?}", annotated_expr.expr));
                self.emitter.write_txt("mov rax, 0");
            }
        }
    }

    #[allow(dead_code)]
    fn emit_expr_to_rcx(&mut self, expr: &AnnotatedExpr<'de>, params: &Vec<(&str, &str)>) {
        let empty_locals = std::collections::HashMap::new();
        self.emit_expr_to_rcx_with_locals(expr, params, &empty_locals);
    }

    fn emit_expr_to_rcx_with_locals(
        &mut self,
        annotated_expr: &AnnotatedExpr<'de>,
        params: &Vec<(&str, &str)>,
        locals: &std::collections::HashMap<&str, i32>,
    ) {
        match &annotated_expr.expr {
            Expr::Literal(Literal::Number(n)) => {
                self.emitter.write_txt(&format!("mov rcx, {}", n));
            }
            Expr::Ident(name) => {
                // Check if it's a local variable
                if let Some(&offset) = locals.get(name.as_ref()) {
                    self.emitter
                        .write_txt(&format!("mov rcx, [rbp - {}]", offset));
                } else if let Some((_, reg)) = params.iter().find(|(n, _)| n == &name.as_ref()) {
                    self.emitter.write_txt(&format!("mov rcx, {}", reg));
                } else {
                    // Use type information for better mangling
                    let g = self
                        .mangler
                        .mangle_variable(name.as_ref(), &annotated_expr.ty);
                    // NASM syntax: use [rel symbol] for position-independent code
                    self.emitter.write_txt(&format!("mov rcx, [rel {}]", g));
                }
            }
            _ => {
                self.emit_expr_to_rax_with_locals(annotated_expr, params, locals);
                self.emitter.write_txt("mov rcx, rax");
            }
        }
    }

    /// Convert a Stmt to AnnotatedStmt (helper for unannotated structures)
    fn stmt_to_annotated(stmt: &Stmt<'de>) -> AnnotatedStmt<'de> {
        match stmt {
            Stmt::Return(Some(expr)) => {
                // Infer type from expression
                let ty = Self::infer_type_from_expr_simple(expr)
                    .unwrap_or_else(|| Type::Primitive(PrimitiveType::Nil));
                AnnotatedStmt::Return(Some(Box::new(AnnotatedExpr::new(*expr.clone(), ty))))
            }
            Stmt::Return(None) => AnnotatedStmt::Return(None),
            Stmt::Expr(expr) => {
                let ty = Self::infer_type_from_expr_simple(expr)
                    .unwrap_or_else(|| Type::Primitive(PrimitiveType::Nil));
                AnnotatedStmt::Expr(Box::new(AnnotatedExpr::new(*expr.clone(), ty)))
            }
            Stmt::VariableDecl(var) => {
                let var_ty = var
                    .type_annotation
                    .clone()
                    .or_else(|| Self::infer_type_from_expr_simple(&var.value))
                    .unwrap_or_else(|| Type::Primitive(PrimitiveType::I32));
                let value_annotated = AnnotatedExpr::new(*var.value.clone(), var_ty.clone());
                AnnotatedStmt::VariableDecl(AnnotatedVariableDecl {
                    name: var.name.clone(),
                    type_annotation: var_ty,
                    value: Box::new(value_annotated),
                })
            }
        }
    }

    /// Emit code for a builtin call
    fn emit_builtin_call(
        &mut self,
        builtin: &BuiltinCall<'de>,
        _annotated_expr: &AnnotatedExpr<'de>,
        params: &Vec<(&str, &str)>,
        locals: &std::collections::HashMap<&str, i32>,
    ) {
        let args = builtin.args.as_ref().map(|v| v.as_slice()).unwrap_or(&[]);
        let name = builtin.name.as_ref();

        match name {
            "println" | "print" => {
                self.emit_print_builtin(name, args, params, locals);
            }
            "unreachable" => {
                self.emit_unreachable_builtin();
            }
            _ => {
                // Unknown builtin - should have been caught by analyzer
                self.emitter
                    .write_comment(&format!("unknown builtin: @{}", name));
                self.emitter.write_txt("mov rax, 0");
            }
        }
    }

    /// Emit code for @println or @print
    fn emit_print_builtin(
        &mut self,
        builtin_name: &str,
        args: &[Expr<'de>],
        params: &Vec<(&str, &str)>,
        locals: &std::collections::HashMap<&str, i32>,
    ) {
        if args.is_empty() {
            // Should have been caught by analyzer, but handle gracefully
            self.emitter
                .write_comment("print builtin called with no arguments");
            self.emitter.write_txt("mov rax, 0");
            return;
        }

        // First argument is the format string
        let format_expr = &args[0];

        // Unwrap Paren expressions to get to the actual expression
        let inner_expr = match format_expr {
            Expr::Paren(inner) => inner.as_ref(),
            _ => format_expr,
        };

        let format_ty = Self::infer_type_from_expr_simple(inner_expr)
            .unwrap_or_else(|| Type::Primitive(PrimitiveType::Str));
        let format_annotated = AnnotatedExpr::new(inner_expr.clone(), format_ty);

        // Evaluate format string to get its address
        // For string literals, we need to emit them to .data section
        // Save format string to stack to avoid being overwritten by argument evaluation
        match inner_expr {
            Expr::Literal(Literal::String(s)) => {
                // String literal - emit to .data section with newline if println
                let label = self.generate_label("fmt_str");
                let mut format_str = s.to_string();

                // Properly escape printf format string:
                // 1. First, replace {} placeholders with a temporary marker to protect them
                // 2. Escape all literal % characters to %%
                // 3. Replace temporary markers back to %d
                let temp_marker = "\u{FFFE}"; // Use a Unicode private use character as temporary marker
                format_str = format_str.replace("{}", temp_marker);
                // Escape all % characters (they'll be %% in the final string)
                format_str = format_str.replace("%", "%%");
                // Replace temporary markers back to %d
                format_str = format_str.replace(temp_marker, "%d");

                if builtin_name == "println" {
                    format_str.push('\n');
                }
                self.emitter.emit_data_string(&label, &format_str);
                // Save format string to stack (use rbp - 8 as temporary, beyond locals)
                self.emitter.write_txt(&format!("mov rax, {}", label));
                self.emitter.write_txt("mov [rbp - 8], rax");
            }
            _ => {
                // Dynamic string - evaluate to rax (should be a pointer)
                self.emit_expr_to_rax_with_locals(&format_annotated, params, locals);
                // Save to stack
                self.emitter.write_txt("mov [rbp - 8], rax");
            }
        }

        // Evaluate additional arguments and place in registers
        // Note: We use rdi, rsi, etc. for function calls, so we evaluate args first
        // then restore the format string to rdi
        let param_regs = ["rsi", "rdx", "rcx", "r8", "r9"];
        for (i, arg_expr) in args.iter().skip(1).take(5).enumerate() {
            let arg_ty = Self::infer_type_from_expr_simple(arg_expr)
                .unwrap_or_else(|| Type::Primitive(PrimitiveType::I32));
            let arg_annotated = AnnotatedExpr::new(arg_expr.clone(), arg_ty);
            self.emit_expr_to_rax_with_locals(&arg_annotated, params, locals);
            self.emitter
                .write_txt(&format!("mov {}, rax", param_regs[i]));
        }

        // Now restore the format string from stack to rdi
        self.emitter.write_txt("mov rdi, [rbp - 8]");

        // For 7+ arguments, we'd need to push to stack, but that's complex
        // For now, we'll support up to 6 arguments (format + 5 more)
        if args.len() > 6 {
            self.emitter
                .write_comment("more than 6 arguments not fully supported");
        }

        // Set rax to 0 (no floating point arguments for printf)
        self.emitter.write_txt("xor rax, rax");

        // Align stack to 16 bytes (System V ABI requirement)
        // We need to check if stack is aligned - for simplicity, we'll assume it is
        // In a full implementation, we'd track stack alignment

        // Call printf
        self.emitter.write_txt("call printf");

        // Flush stdout to ensure output appears (important with -nostartfiles)
        // Call fflush(NULL) to flush all streams
        self.emitter.write_txt("mov rdi, 0"); // NULL
        self.emitter.write_txt("call fflush");

        // Return Nil (0)
        self.emitter.write_txt("mov rax, 0");
    }

    /// Emit code for @unreachable
    fn emit_unreachable_builtin(&mut self) {
        self.emitter.write_comment("@unreachable: calling abort()");
        // Call abort - it never returns
        self.emitter.write_txt("call abort");
        // This should never be reached, but set rax to 0 just in case
        self.emitter.write_txt("mov rax, 0");
    }

    /// Simple type inference for unannotated expressions (used as fallback)
    fn infer_type_from_expr_simple(expr: &Expr<'de>) -> Option<Type<'de>> {
        match expr {
            Expr::Literal(Literal::Number(_)) => Some(Type::Primitive(PrimitiveType::I32)),
            Expr::Literal(Literal::String(_)) => Some(Type::Primitive(PrimitiveType::Str)),
            Expr::Literal(Literal::Char(_)) => Some(Type::Primitive(PrimitiveType::Char)),
            Expr::Literal(Literal::Boolean(_)) => Some(Type::Primitive(PrimitiveType::Bool)),
            Expr::Literal(Literal::Nil) => Some(Type::Primitive(PrimitiveType::Nil)),
            _ => None,
        }
    }

    pub fn emit(mut self) -> String {
        self.codegen();
        self.emitter.emit()
    }

    /// Helper to find a type declaration in the program
    fn find_type_decl(&self, type_name: &str) -> Option<&TypeDecl<'de>> {
        for item in &self.program.items {
            if let AnnotatedTopLevelItem::TypeDecl(type_decl) = item {
                if type_decl.name.as_ref() == type_name {
                    return Some(type_decl);
                }
            }
        }
        None
    }

    /// Helper to find a method in a struct's impl block
    fn find_method_in_struct(&self, type_name: &str, method_name: &str) -> Option<&Function<'de>> {
        if let Some(type_decl) = self.find_type_decl(type_name) {
            if let TypeDeclKind::Struct(struct_decl) = &type_decl.decl {
                if let Some(impl_block) = &struct_decl.impl_block {
                    for func in impl_block {
                        if func.name.as_ref() == method_name {
                            return Some(func);
                        }
                    }
                }
            }
        }
        None
    }

    /// Emit code for a method call
    fn emit_method_call(
        &mut self,
        annotated_expr: &AnnotatedExpr<'de>,
        receiver: &Expr<'de>,
        method: &Cow<'de, str>,
        args: &[Expr<'de>],
        params: &Vec<(&str, &str)>,
        locals: &std::collections::HashMap<&str, i32>,
    ) {
        // Determine if this is a static method (receiver is a type) or instance method
        let is_static = matches!(receiver, Expr::Ident(_));

        if is_static {
            // Static method call: Person:new()
            if let Expr::Ident(type_name) = receiver {
                // Look up the method
                if let Some(_func) = self.find_method_in_struct(type_name.as_ref(), method.as_ref())
                {
                    // Evaluate arguments and place in System V parameter registers
                    let param_regs = ["rdi", "rsi", "rdx", "rcx", "r8", "r9"];

                    // For static methods, all args go to param registers
                    let args_to_pass = args;
                    for (i, arg_expr) in args_to_pass.iter().take(6).enumerate() {
                        let arg_annotated = AnnotatedExpr::new(
                            arg_expr.clone(),
                            Type::Primitive(PrimitiveType::I32), // Placeholder type
                        );
                        if i == 0 {
                            self.emit_expr_to_rax_with_locals(&arg_annotated, params, locals);
                            self.emitter
                                .write_txt(&format!("mov {}, rax", param_regs[i]));
                        } else {
                            self.emit_expr_to_rax_with_locals(&arg_annotated, params, locals);
                            self.emitter.write_txt("mov r10, rax");
                            self.emitter
                                .write_txt(&format!("mov {}, r10", param_regs[i]));
                        }
                    }

                    // Generate mangled function name: TypeName_methodName
                    let method_label =
                        self.mangler
                            .mangle(&format!("{}:{}", type_name.as_ref(), method.as_ref()));
                    self.emitter.write_txt(&format!("call {}", method_label));
                    // Return value is already in rax
                    return;
                }
            }
        } else {
            // Instance method call: my_person.intro()
            // First, evaluate the receiver (object) to get 'self'
            let receiver_annotated = AnnotatedExpr::new(
                receiver.clone(),
                annotated_expr.ty.clone(), // Use the annotated type
            );
            self.emit_expr_to_rax_with_locals(&receiver_annotated, params, locals);

            // Save 'self' to rdi (first parameter)
            self.emitter.write_txt("mov rdi, rax");

            // Infer the receiver type to find the method
            // For now, we'll use a simple approach: if receiver is an identifier, look it up
            let type_name = if let Expr::Ident(var_name) = receiver {
                // Look up variable type
                if let Some(&_ty) = locals.get(var_name.as_ref()) {
                    // Variable is a local - we need to infer type from context
                    // For now, try to find type from annotated_expr.ty
                    if let Type::Named(name) = &annotated_expr.ty {
                        Some(name.as_ref())
                    } else {
                        None
                    }
                } else if let Some((_, _reg)) =
                    params.iter().find(|(name, _)| *name == var_name.as_ref())
                {
                    // Variable is a parameter - can't easily get type here
                    // Try to infer from annotated_expr.ty
                    if let Type::Named(name) = &annotated_expr.ty {
                        Some(name.as_ref())
                    } else {
                        None
                    }
                } else {
                    None
                }
            } else {
                // Receiver is not an identifier - try to infer from annotated type
                if let Type::Named(name) = &annotated_expr.ty {
                    Some(name.as_ref())
                } else {
                    None
                }
            };

            if let Some(type_name) = type_name {
                if let Some(func) = self.find_method_in_struct(type_name, method.as_ref()) {
                    // Check if first param is 'self' - if so, skip it
                    let args_to_pass = if func
                        .params
                        .first()
                        .map(|p| p.name.as_ref() == "self")
                        .unwrap_or(false)
                    {
                        args
                    } else {
                        args
                    };

                    // Evaluate remaining arguments
                    let param_regs = ["rdi", "rsi", "rdx", "rcx", "r8", "r9"];
                    for (i, arg_expr) in args_to_pass.iter().take(5).enumerate() {
                        let arg_annotated = AnnotatedExpr::new(
                            arg_expr.clone(),
                            Type::Primitive(PrimitiveType::I32), // Placeholder type
                        );
                        self.emit_expr_to_rax_with_locals(&arg_annotated, params, locals);
                        self.emitter.write_txt("mov r10, rax");
                        self.emitter
                            .write_txt(&format!("mov {}, r10", param_regs[i + 1]));
                    }

                    // Generate mangled function name: TypeName_methodName
                    let method_label =
                        self.mangler
                            .mangle(&format!("{}:{}", type_name, method.as_ref()));
                    self.emitter.write_txt(&format!("call {}", method_label));
                    // Return value is already in rax
                    return;
                }
            }
        }

        // Fallback: method not found
        self.emitter
            .write_comment(&format!("method call not fully implemented: {:?}", method));
        self.emitter.write_txt("mov rax, 0");
    }

    /// Emit code for member access
    fn emit_member_access(
        &mut self,
        annotated_expr: &AnnotatedExpr<'de>,
        object: &Expr<'de>,
        field: &MemberField<'de>,
        params: &Vec<(&str, &str)>,
        locals: &std::collections::HashMap<&str, i32>,
    ) {
        match field {
            MemberField::Name(field_name) => {
                // Field access: my_person.name
                // First, evaluate the object
                let object_annotated =
                    AnnotatedExpr::new(object.clone(), annotated_expr.ty.clone());
                self.emit_expr_to_rax_with_locals(&object_annotated, params, locals);

                // For now, we'll assume structs are represented as pointers
                // and fields are accessed via offsets
                // This is a simplified implementation - in reality, we'd need to:
                // 1. Look up the struct type
                // 2. Find the field offset
                // 3. Load the field value

                // For now, just return 0 as a placeholder
                self.emitter.write_comment(&format!(
                    "member access not fully implemented: {:?}",
                    field_name
                ));
                self.emitter.write_txt("mov rax, 0");
            }
            MemberField::Index(_) => {
                // Index access: my_list[0]
                self.emitter
                    .write_comment("index access not yet implemented");
                self.emitter.write_txt("mov rax, 0");
            }
        }
    }

    /// Calculate the size needed for a struct literal
    fn calculate_struct_size(&self, fields: &[StructFieldInit<'de>]) -> usize {
        // Each field is 8 bytes (64-bit values)
        // Aligned to 8 bytes (already aligned since we use 8-byte fields)
        fields.len() * 8
    }

    /// Emit code for a struct literal
    fn emit_struct_literal(
        &mut self,
        _annotated_expr: &AnnotatedExpr<'de>,
        _type_: &Option<Type<'de>>,
        fields: &[StructFieldInit<'de>],
        params: &Vec<(&str, &str)>,
        locals: &std::collections::HashMap<&str, i32>,
    ) {
        // For anonymous structs (type_ is None) or typed structs, evaluate each field and store them on the stack
        // Calculate the total size needed (sum of field sizes, aligned to 8 bytes)
        let struct_size = self.calculate_struct_size(fields);

        // Allocate stack space by adjusting rsp
        self.emitter.write_txt(&format!("sub rsp, {}", struct_size));

        // Store current rsp in a temporary register (r10) as the struct base address
        self.emitter.write_txt("mov r10, rsp");

        // For each field in order:
        for (index, field) in fields.iter().enumerate() {
            // Calculate offset: field_index * 8
            let offset = index * 8;

            // Evaluate field value to rax
            let field_value_annotated = AnnotatedExpr::new(
                *field.value.clone(),
                Type::Primitive(PrimitiveType::I32), // Placeholder type - could be improved with proper type inference
            );
            self.emit_expr_to_rax_with_locals(&field_value_annotated, params, locals);

            // Store: mov [r10 + offset], rax
            self.emitter
                .write_txt(&format!("mov [r10 + {}], rax", offset));
        }

        // Move struct address to rax
        self.emitter.write_txt("mov rax, r10");
    }

    /// Emit code for an enum variant
    fn emit_enum_variant(
        &mut self,
        annotated_expr: &AnnotatedExpr<'de>,
        variant_name: &Cow<'de, str>,
        value: &Option<EnumVariantValue<'de>>,
        params: &Vec<(&str, &str)>,
        locals: &std::collections::HashMap<&str, i32>,
    ) {
        // Find the enum type from context (infer from annotated_expr.ty if it's Type::Named)
        let enum_type_name = if let Type::Named(name) = &annotated_expr.ty {
            Some(name.as_ref())
        } else {
            // If type isn't available from annotation, search all enum declarations
            self.find_enum_type_by_variant(variant_name.as_ref())
        };

        // Look up the enum declaration to find the variant index
        let variant_index = if let Some(type_name) = enum_type_name {
            self.find_enum_variant_index(type_name, variant_name.as_ref())
        } else {
            None
        };

        // Calculate payload size
        let payload_size = if let Some(val) = value {
            match val {
                EnumVariantValue::Single(expr) => {
                    // For single values, check if it's a struct literal
                    if let Expr::StructLit { fields, .. } = expr.as_ref() {
                        self.calculate_struct_size(fields)
                    } else {
                        8 // Single value is 8 bytes
                    }
                }
                EnumVariantValue::Tuple(exprs) => {
                    exprs.len() * 8 // Each tuple element is 8 bytes
                }
            }
        } else {
            0 // No payload
        };

        // Total size: 8 bytes (tag) + payload size
        let total_size = 8 + payload_size;

        // Allocate stack space: sub rsp, <total_size>
        self.emitter.write_txt(&format!("sub rsp, {}", total_size));

        // Store variant index (tag) at [rsp]: mov [rsp], <variant_index>
        let tag_value = variant_index.unwrap_or(0);
        self.emitter
            .write_txt(&format!("mov qword [rsp], {}", tag_value));

        // If variant has a value:
        if let Some(val) = value {
            match val {
                EnumVariantValue::Single(expr) => {
                    // Evaluate value expression (could be StructLit, Tuple, or single Expr)
                    // Check if it's a struct literal - if so, handle specially
                    if let Expr::StructLit { fields, .. } = expr.as_ref() {
                        // For struct literals, construct them at offset 8 (payload area)
                        // Store rsp + 8 in r10 as the struct base address
                        self.emitter.write_txt("mov r10, rsp");
                        self.emitter.write_txt("add r10, 8"); // Point to payload area

                        // For each field, evaluate and store at the appropriate offset
                        for (index, field) in fields.iter().enumerate() {
                            let offset = index * 8;
                            let field_value_annotated = AnnotatedExpr::new(
                                *field.value.clone(),
                                Type::Primitive(PrimitiveType::I32), // Placeholder
                            );
                            self.emit_expr_to_rax_with_locals(
                                &field_value_annotated,
                                params,
                                locals,
                            );
                            self.emitter
                                .write_txt(&format!("mov [r10 + {}], rax", offset));
                        }
                    } else {
                        // Single value - evaluate and store at offset 8
                        let value_annotated = AnnotatedExpr::new(
                            *expr.clone(),
                            Type::Primitive(PrimitiveType::I32), // Placeholder
                        );
                        self.emit_expr_to_rax_with_locals(&value_annotated, params, locals);
                        self.emitter.write_txt("mov [rsp + 8], rax");
                    }
                }
                EnumVariantValue::Tuple(exprs) => {
                    // For tuples, store each element at offset 8 + (index * 8)
                    for (index, expr) in exprs.iter().enumerate() {
                        let offset = 8 + (index * 8);
                        let expr_annotated = AnnotatedExpr::new(
                            expr.clone(),
                            Type::Primitive(PrimitiveType::I32), // Placeholder
                        );
                        self.emit_expr_to_rax_with_locals(&expr_annotated, params, locals);
                        self.emitter
                            .write_txt(&format!("mov [rsp + {}], rax", offset));
                    }
                }
            }
        }

        // Move enum address to rax: mov rax, rsp
        self.emitter.write_txt("mov rax, rsp");
    }

    /// Find the index of a variant in an enum
    fn find_enum_variant_index(&self, type_name: &str, variant_name: &str) -> Option<usize> {
        if let Some(type_decl) = self.find_type_decl(type_name) {
            if let TypeDeclKind::Enum(enum_decl) = &type_decl.decl {
                for (index, variant) in enum_decl.variants.iter().enumerate() {
                    if variant.name.as_ref() == variant_name {
                        return Some(index);
                    }
                }
            }
        }
        None
    }

    /// Find the enum type name by searching for a variant name across all enum declarations
    fn find_enum_type_by_variant(&self, variant_name: &str) -> Option<&str> {
        for item in &self.program.items {
            if let AnnotatedTopLevelItem::TypeDecl(type_decl) = item {
                if let TypeDeclKind::Enum(enum_decl) = &type_decl.decl {
                    // Check if this enum contains the variant
                    for variant in &enum_decl.variants {
                        if variant.name.as_ref() == variant_name {
                            return Some(type_decl.name.as_ref());
                        }
                    }
                }
            }
        }
        None
    }

    /// Find a function by name and return its mangled name
    fn find_function_mangled_name(&self, name: &str, call_args: &[Expr<'de>]) -> Option<String> {
        for item in &self.program.items {
            if let AnnotatedTopLevelItem::Function(func) = item {
                if func.name.as_ref() == name {
                    // Check if argument count matches
                    if call_args.len() != func.params.len() {
                        continue;
                    }

                    // Get parameter types
                    let param_types: Vec<Type> = func
                        .params
                        .iter()
                        .map(|p| p.type_annotation.clone())
                        .collect();

                    // Get generics
                    let generics: Option<Vec<&str>> = if func.generics.is_empty() {
                        None
                    } else {
                        Some(func.generics.iter().map(|g| g.as_ref()).collect())
                    };

                    // Generate mangled name
                    let mangled = self.mangler.mangle_function(
                        func.name.as_ref(),
                        &param_types,
                        &func.return_type,
                        generics.as_deref(),
                    );
                    return Some(mangled);
                }
            }
        }
        None
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{analyzer::analyze, parser::Parser};

    #[test]
    fn test_codegen_function_and_vars() {
        let src = r#"
let add :: a, b = a + b
let msg := "Hello \n"
let x := 42
"#;
        let parser = Parser::new(src);
        let whole = parser.whole.to_string();
        let program = analyze(parser.parse().unwrap(), &whole).unwrap();
        let cg = Codegen::from_annotated_program("ns_".into(), program).unwrap();
        let out = cg.emit();
        // function directives and label
        assert!(out.contains(".globl ns_add"));
        assert!(out.contains("ns_add:"));
        assert!(out.contains("ret") || out.contains("leave"));

        // data directives
        assert!(out.contains(".globl ns_msg"));
        assert!(out.contains(".asciz"));
        assert!(out.contains(".globl ns_x"));
        assert!(out.contains(".quad 42"));

        // simple instruction checks for `add :: a, b = a + b`
        assert!(out.contains("mov rax, rdi") || out.contains("mov rax, rsi"));
        assert!(out.contains("add rax, rsi") || out.contains("add rax, rdi"));
    }
}
