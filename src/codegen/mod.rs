use crate::parser::ast::*;
use crate::parser::{Parser, ast::Program};
use emitter::Emitter;
use mangler::Mangler;
use miette::Error;

mod emitter;
mod mangler;

#[derive(Debug)]
pub struct Codegen<'de> {
    program: Program<'de>,
    emitter: Emitter,
    mangler: Mangler,
}

impl<'de> Codegen<'de> {
    pub fn new(name: String, parser: Parser<'de>) -> Result<Self, Error> {
        Ok(Self {
            program: parser.parse()?,
            emitter: Emitter::default(),
            mangler: Mangler::new(name),
        })
    }

    /// Create a Codegen from an already-parsed program
    pub fn from_program(name: String, program: Program<'de>) -> Result<Self, Error> {
        Ok(Self {
            program,
            emitter: Emitter::default(),
            mangler: Mangler::new(name),
        })
    }

    fn codegen(&mut self) {
        // Emit a small header comment
        self.emitter.write_comment("generated by novac");

        // Clone items to avoid borrowing `self` immutably while we mutate `self`
        let items = self.program.items.clone();
        for item in items {
            match item {
                TopLevelItem::Function(func) => {
                    let label = self.mangler.mangle(func.name.as_ref());
                    // x86_64 / System V: export symbol and mark as function
                    self.emitter.write_txt(&format!(".globl {}", label));
                    self.emitter
                        .write_txt(&format!(".type {}, @function", label));
                    self.emitter.write_txt_label(&label);
                    self.emitter
                        .write_comment(&format!("function {}", func.name));
                    // System V prologue
                    self.emitter.write_txt("push rbp");
                    self.emitter.write_txt("mov rbp, rsp");
                    // align stack if needed later

                    // Parameter register mapping
                    let mut param_regs: Vec<(&str, &str)> = Vec::new();
                    for (i, p) in func.params.iter().enumerate() {
                        param_regs.push((p.name.as_ref(), Self::reg_for_param(i)));
                    }

                    // Lower the function body into instructions
                    self.generate_function_body(&func, &param_regs);

                    // System V epilogue
                    self.emitter.write_txt("leave");
                    self.emitter.write_txt("ret");
                    // size directive
                    self.emitter
                        .write_txt(&format!(".size {}, .-{}", label, label));
                }
                TopLevelItem::VariableDecl(var) => {
                    let label = self.mangler.mangle(var.name.as_ref());
                    match *var.value.clone() {
                        Expr::Literal(Literal::String(ref s)) => {
                            // data symbol, align and export
                            self.emitter.write_dat(&format!(".globl {}", label));
                            self.emitter.write_dat(&format!(".align 8"));
                            self.emitter.emit_data_string(&label, s.as_ref());
                        }
                        Expr::Literal(Literal::Number(n)) => {
                            self.emitter.write_dat(&format!(".globl {}", label));
                            self.emitter.write_dat(&format!(".align 8"));
                            self.emitter.write_dat_label(&label);
                            self.emitter.write_dat(&format!(".quad {}", n));
                        }
                        _ => {
                            // fallback: emit label and a comment placeholder
                            self.emitter.write_dat_label(&label);
                            self.emitter.write_dat("; unhandled initializer");
                        }
                    }
                }
                TopLevelItem::TypeDecl(_) => {
                    // TODO: emit type declarations when needed
                }
            }
        }
    }

    fn reg_for_param(i: usize) -> &'static str {
        match i {
            0 => "rdi",
            1 => "rsi",
            2 => "rdx",
            3 => "rcx",
            4 => "r8",
            5 => "r9",
            _ => "rdi",
        }
    }

    fn generate_function_body(&mut self, func: &Function<'de>, params: &Vec<(&str, &str)>) {
        // Only handle simple bodies for now: Single(expr) or Block with return
        match &func.body {
            ExprList::Single(expr) => {
                self.emit_expr_to_rax(expr, params);
            }
            ExprList::Block(stmts) => {
                for stmt in stmts {
                    match stmt {
                        Stmt::Return(Some(expr)) => {
                            self.emit_expr_to_rax(expr, params);
                            break;
                        }
                        Stmt::Expr(expr) => {
                            let _ = self.emit_expr_to_rax(expr, params);
                        }
                        Stmt::VariableDecl(_) => {
                            // TODO: support locals later
                        }
                        Stmt::Return(None) => {
                            self.emitter.write_txt("mov rax, 0");
                            break;
                        }
                    }
                }
            }
        }
    }

    fn emit_expr_to_rax(&mut self, expr: &Expr<'de>, params: &Vec<(&str, &str)>) {
        match expr {
            Expr::Literal(Literal::Number(n)) => {
                self.emitter.write_txt(&format!("mov rax, {}", n));
            }
            Expr::Ident(name) => {
                if let Some((_, reg)) = params.iter().find(|(n, _)| n == &name.as_ref()) {
                    self.emitter.write_txt(&format!("mov rax, {}", reg));
                } else {
                    let g = self.mangler.mangle(name.as_ref());
                    self.emitter
                        .write_txt(&format!("mov rax, QWORD PTR [rel {}]", g));
                }
            }
            Expr::Binary { left, op, right } => {
                // Evaluate left into rax
                self.emit_expr_to_rax(left, params);

                // Prepare right operand
                let right_op = match &**right {
                    Expr::Literal(Literal::Number(n)) => format!("{}", n),
                    Expr::Ident(n) => {
                        if let Some((_, reg)) = params.iter().find(|(name, _)| name == &n.as_ref())
                        {
                            (*reg).to_string()
                        } else {
                            self.mangler.mangle(n.as_ref())
                        }
                    }
                    _ => {
                        self.emit_expr_to_rcx(right, params);
                        "rcx".to_string()
                    }
                };

                match op {
                    BinOp::Add => self.emitter.write_txt(&format!("add rax, {}", right_op)),
                    BinOp::Sub => self.emitter.write_txt(&format!("sub rax, {}", right_op)),
                    BinOp::Mul => self.emitter.write_txt(&format!("imul rax, {}", right_op)),
                    BinOp::Div => {
                        self.emitter.write_txt("cqo");
                        if right_op.chars().all(|c| c.is_ascii_digit()) {
                            self.emitter.write_txt(&format!("mov rcx, {}", right_op));
                            self.emitter.write_txt("idiv rcx");
                        } else {
                            self.emitter.write_txt(&format!("idiv {}", right_op));
                        }
                    }
                    _ => {
                        self.emitter
                            .write_comment(&format!("unhandled op: {:?}", op));
                    }
                }
            }
            _ => {
                self.emitter
                    .write_comment(&format!("unhandled expr: {:?}", expr));
                self.emitter.write_txt("mov rax, 0");
            }
        }
    }

    fn emit_expr_to_rcx(&mut self, expr: &Expr<'de>, params: &Vec<(&str, &str)>) {
        match expr {
            Expr::Literal(Literal::Number(n)) => {
                self.emitter.write_txt(&format!("mov rcx, {}", n));
            }
            Expr::Ident(name) => {
                if let Some((_, reg)) = params.iter().find(|(n, _)| n == &name.as_ref()) {
                    self.emitter.write_txt(&format!("mov rcx, {}", reg));
                } else {
                    let g = self.mangler.mangle(name.as_ref());
                    self.emitter
                        .write_txt(&format!("mov rcx, QWORD PTR [rel {}]", g));
                }
            }
            _ => {
                self.emit_expr_to_rax(expr, params);
                self.emitter.write_txt("mov rcx, rax");
            }
        }
    }

    pub fn emit(mut self) -> String {
        self.codegen();
        self.emitter.emit()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::Parser;

    #[test]
    fn test_codegen_function_and_vars() {
        let src = r#"
let add :: a, b = a + b
let msg := "Hello \n"
let x := 42
"#;
        let parser = Parser::new(src);
        let cg = Codegen::new("ns_".into(), parser).unwrap();
        let out = cg.emit();
        // function directives and label
        assert!(out.contains(".globl ns_add"));
        assert!(out.contains("ns_add:"));
        assert!(out.contains("ret") || out.contains("leave"));

        // data directives
        assert!(out.contains(".globl ns_msg"));
        assert!(out.contains(".asciz"));
        assert!(out.contains(".globl ns_x"));
        assert!(out.contains(".quad 42"));

        // simple instruction checks for `add :: a, b = a + b`
        assert!(out.contains("mov rax, rdi") || out.contains("mov rax, rsi"));
        assert!(out.contains("add rax, rsi") || out.contains("add rax, rdi"));
    }
}
