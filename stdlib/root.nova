(*! Option represents existance or absence of a value. *)
let Option[T] :: = enum {
	some :: T,
	none :: (),
} with {
	(*! Returns true when the Option holds a value. *)
	let is_some :: self = match self with
		| .some(_) -> true
		| .none    -> false
	
	(*! Returns true when the Option is none. *)
	let is_none :: self = !self.is_some()

	(*! Retrieves the contained value; panics if none. *)
	let unwrap :: self = self.some
}

(*! Result represents success (ok) or failure (err). *)
let Result[T, E] :: = enum {
	ok :: T,
	err :: E,
}

let String :: ()
= struct {
	internal: str,
	size: usize,
} with {
	(*! Constructs an empty String. *)
	let new :: () 
	= Self {
		.internal = "",
		.size = 0,
	}

	(*! Builds a String from an existing str. *)
	let from :: internal
	= Self {
		.internal = internal,
		.size = 0,
	}
}
