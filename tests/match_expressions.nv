let test_match_literal :: my_int 
= match my_int {
    | 1 -> @println("one")
    | x if x == 2 or x == 3 -> @println("zwei oder drei")
    }

let x := "placeholder for testing"

let test_match_list :: my_list 
= match my_list {
    | [head, ..] -> do_head(head),
    | [_, ..tail] -> do_tail(tail),
    | [.., last] -> do_last(last),
    | [] -> do_empty(),
    | _ -> @unreachable
    }

/* Match on strings */

/* `str` is a special type in Supernova
 * In this example, `head` will become
 *  all characters BEFORE delimeter,
 *  and `tail` will be all characters AFTER
 *  the delimeter
 */
let lex :: s, ls -> list<str> =
    match s {
    | word :: ' ' :: tail -> lex(tail, ls.append(word)),
    | word -> ls.append(word)
    | _ -> @unreachable
    }


